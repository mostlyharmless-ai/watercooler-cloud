#!/usr/bin/env python3
"""Git credential helper for Watercooler.

This credential helper integrates with the watercooler-site dashboard to provide
seamless GitHub authentication for git operations.

When git needs credentials for HTTPS operations (clone, push, pull), it calls
this script which fetches the user's GitHub token from the dashboard API.

Usage:
    git config --global credential.helper watercooler

    Or configure automatically via MCP server environment:
    WATERCOOLER_DASHBOARD_URL=https://watercooler.example.com

Protocol:
    Git credential helpers use a simple text protocol via stdin/stdout.
    Input format:
        protocol=https
        host=github.com

    Output format:
        username=token
        password=<github-token>
"""

import os
import sys
import urllib.request
import urllib.error
import json
from pathlib import Path
from typing import Dict, Optional


def get_dashboard_url() -> str:
    """Get dashboard URL from environment or use default."""
    return os.environ.get(
        "WATERCOOLER_DASHBOARD_URL",
        "https://watercoolerdev.com"
    )


def parse_credential_input() -> Dict[str, str]:
    """Parse git credential protocol input from stdin.

    Returns:
        Dictionary of key-value pairs from stdin
    """
    attrs = {}
    for line in sys.stdin:
        line = line.strip()
        if not line:
            break
        if "=" in line:
            key, value = line.split("=", 1)
            attrs[key] = value
    return attrs


def _check_file_permissions(path: Path) -> None:
    """Warn if file has insecure permissions (Unix/Mac only)."""
    if hasattr(os, 'stat') and os.name != 'nt':
        mode = path.stat().st_mode & 0o777
        if mode & 0o077:  # Check if group/other have any permissions
            sys.stderr.write(f"Warning: {path} has insecure permissions {oct(mode)}\n")
            sys.stderr.write(f"Recommended: chmod 600 {path}\n")


def _read_toml_credentials(path: Path) -> Optional[str]:
    """Read GitHub token from TOML credentials file.

    Simple TOML parser that handles the credentials format:
        [github]
        token = "..."
    """
    try:
        content = path.read_text()
        in_github_section = False

        for line in content.split('\n'):
            line = line.strip()
            if not line or line.startswith('#'):
                continue

            # Check for section header
            if line.startswith('[') and line.endswith(']'):
                in_github_section = line == '[github]'
                continue

            # Parse key-value in [github] section
            if in_github_section and '=' in line:
                key, value = line.split('=', 1)
                key = key.strip()
                value = value.strip()
                if key == 'token':
                    # Remove quotes
                    if (value.startswith('"') and value.endswith('"')) or \
                       (value.startswith("'") and value.endswith("'")):
                        value = value[1:-1]
                    return value

        return None
    except Exception:
        return None


def _read_json_credentials(path: Path) -> Optional[str]:
    """Read GitHub token from legacy JSON credentials file."""
    try:
        with open(path, 'r') as f:
            creds = json.load(f)
        return creds.get("github_token")
    except (FileNotFoundError, json.JSONDecodeError, PermissionError, KeyError):
        return None


def read_local_credentials() -> Optional[str]:
    """Read GitHub token from local credentials file.

    Tries TOML format first (credentials.toml), then falls back to
    legacy JSON format (credentials.json) for backwards compatibility.

    Returns:
        GitHub token string, or None if file doesn't exist or is invalid
    """
    watercooler_dir = Path.home() / ".watercooler"

    # Try TOML format first (preferred)
    toml_path = watercooler_dir / "credentials.toml"
    if toml_path.exists():
        _check_file_permissions(toml_path)
        token = _read_toml_credentials(toml_path)
        if token:
            return token

    # Fall back to legacy JSON format
    json_path = watercooler_dir / "credentials.json"
    if json_path.exists():
        _check_file_permissions(json_path)
        token = _read_json_credentials(json_path)
        if token:
            return token

    return None


def fetch_token_from_dashboard() -> Optional[str]:
    """Fetch GitHub token using priority order.

    Priority:
    1. Local credentials file (~/.watercooler/credentials.toml or credentials.json)
    2. WATERCOOLER_GITHUB_TOKEN environment variable
    3. GITHUB_TOKEN environment variable
    4. GH_TOKEN environment variable

    Returns:
        GitHub token string, or None if unavailable
    """
    # Priority 1: Local credentials file (written by dashboard)
    token = read_local_credentials()
    if token:
        return token

    # Priority 2: Dedicated Watercooler token
    token = os.environ.get("WATERCOOLER_GITHUB_TOKEN")
    if token:
        return token

    # Priority 3 & 4: Standard GitHub token environment variables
    token = os.environ.get("GITHUB_TOKEN") or os.environ.get("GH_TOKEN")
    return token


def main():
    """Main credential helper entry point."""
    if len(sys.argv) < 2:
        sys.stderr.write("Usage: git-credential-watercooler <get|store|erase>\n")
        sys.exit(1)

    action = sys.argv[1]

    if action == "get":
        # Parse input from git
        attrs = parse_credential_input()

        # Only handle github.com for now
        if attrs.get("host") != "github.com":
            sys.exit(0)

        # Fetch token from dashboard or environment
        token = fetch_token_from_dashboard()

        if token:
            # Output credentials in git protocol format
            print(f"username=token")
            print(f"password={token}")
        else:
            # No credentials available
            sys.exit(1)

    elif action == "store":
        # We don't store credentials (they come from dashboard)
        sys.exit(0)

    elif action == "erase":
        # We don't erase credentials (they're managed by dashboard)
        sys.exit(0)

    else:
        sys.stderr.write(f"Unknown action: {action}\n")
        sys.exit(1)


if __name__ == "__main__":
    main()
